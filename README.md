**Реєстрація** (виконується по сабміту форми):

- Frontend
  - запит: POST, body включає логін/пароль (креди)
  - відповідь: створений користувач + кукі, які включають `accessToken`, `refreshToken`
- Backend
  - запит: отримує креди, шифрує пароль, створює в нового користувача і зберігає в колекції users БД. Створює нову сессію з прив'язкою до користувача, зберігає в коллекції sessions в БД. Сессія включає пару токенів: `accessToken`, `refreshToken`.
  - відповідь: повертає json з об'єктом створеного користувача (без пароля). Через httpOnly кукі передає `accessToken`, `refreshToken`.

**Логін** (виконується по сабміту форми):

- Frontend
  - запит: POST, body включає логін/пароль (креди)
  - відповідь: повертає користувача + кукі, які включають `accessToken`, `refreshToken`
- Backend
  - запит: отримує креди, шукає в БД користувача та активні сессії. Якщо є активна сессія, вона може бути видалена і створена нова
  - відповідь: повертає json з об'єктом користувача (без пароля). Через httpOnly кукі передає `accessToken`, `refreshToken`.

> Всі інші запити - приватні. Відповідно, вони потребують обов'язкової передачі ``accessToken``, ``refreshToken`` для отримання доступу до даних бекенду. На фронті в конфіг axios потрібно включити `withCredentials: true` для того, щоб передавати кукі через заголовоки.

**Логаут** (виконується по кліку на кнопку логауту):

- Frontend
  - запит: POST, body не потрібний. Через заголовки передаються кукі з `accessToken`, `refreshToken`
  - відповідь: нічого не повертає (або тестове повідомлення) очищає кукі.
- Backend
  - запит: отримує `accessToken`, перевіряє на валідність. У разі валідності і актуальності токену - повертає 401 помилку. У разі, якщо токен валідний, шукає сессію в ДБ і очищає сессію.
  - відповідь: нічого не повертає (або json з тестовим повідомленням). Очищає кукі.

**Перевірка і оновлення сессії** (є різні стратегії запуску операції. Наприклад: автоматично раз в певний період, поки не протух `accessToken`, під час переходів між сторінками, під час отримання 401 помилки автоматичний запит. Всі стратегії направлені на підтримку забереження стану аутентифікації користувача):

- Frontend
  - запит: GET. Через заголовки передаються кукі з `accessToken`, `refreshToken` (або тільки `refreshToken`, якщо `accessToken` протух, або без кукі, якщо обидва протухли)
  - відповідь: різний формат відповіді + оновлені кукі з `accessToken`, `refreshToken`.
- Backend
  - запит: отримує кукі. Починає з перевірки `accessToken`, якщо немає `refreshToken`. Зчитує інформацію з них, перевіряє валідність, знаходить в БД сессію, оновлює сессію в БД (видаляє стару, створює нову)
  - відповідь: різний формат відповіді + оновлені кукі з `accessToken`, `refreshToken`.


На стороні додатку потрібно реалізувати глобальний стан для зберігання стану користувача (user, isLoggedIn etc.). На основі цього стану будується інтерфейс.

Також, частиною реалізації аутентифікації є захист маршрутів. Не залогінений користувач не повинен мати доступ до приватних сторінок, залогінений користувач не повинен мати доступн до сторінок аутентифікації (login, register).


Це загальна концепція як для реакт додатків, так і додатків, написаних на Next.js. Також може відрізнятися складність процесу актунтифікації, наприклад (пошта )

Ньюанси, які можуть виникнути в додатках Next.js

В Next.js без проблем кукі автоматично передаються, якщо запит виконується на клієнті. На сервері немає доступу до Browser API (до сховища кукі в браузері).

Для вирішення цієї проблеми Next.js надає асинхронну функцію `cookies()`, яка надає можливість створити в межах Next.js сховище і записути, тобто зберігати кукі з відповідей запитів. А в потрібний момент зчитувати з нього кукі в серверних компонентах. Умовно кажучи - це допоміжне сховище в межах некст серверу.

Для реалізації можна зробити наступні дії:
1. Cтворити проксі-сервер між Next.js та зовнім бекендом. Це буде набір route-хендлерів:
  - Запити першочергово йдуть на проксі-сервер
  - Проксі-сервер виконує запити на зовнішній бекенд.

  Основна мета створення проксі-серверу:  
  - Отримати з відповіді зовнішнього бекенду заголовки з куками і зберігти їх в `cookieStore` для подальшого використання в інших серверних функціях, яким необхідно використати збережені куки.
  - Виконати запит на зовнішній бекенд і прокинути успішну відповідь далі у браузер, або прокинути у браузер помилку і статус.

2. Створити пари-функцій для запитів, одні з яких будуть виконуватись в клієнтських компонентах, інші - в серверних компонентах, функціях. Єдина різниця між ними полягає в тому, що в серверних функціях потрібно вручну отримувати кукі з `cookies()` та передавати кукі в заголовки запиту.

**Можливий порядок виконання ДЗ:**

1. До існуючого проекту додати набір сторінок (login page, register page, profile page, profile edit page, навігаційну панель, яка буде включати набір потрібних елементів навігації і компонентів). Побудувати інтерфейс сторінок. Прописати загальну логіку цих сторінок:
  Сторінка реєстрації (клієнтський компонент):
  1. Створити форму реєстрації та обробник сабміту.
  2. запит на реєстрацію і отримання юзера
  3. оновлення стану аутентифікації створеного юзера
  4. редірект на сторінку profile
  Сторінка логіну (клієнтський компонент):
  1. Створити форму логіну та обробник сабміту.
  2. login і отримання юзера.
  3. оновлення стану аутентифікації створеного юзера
  4. редірект на сторінку profile
  Сторінка профілю (сервений компонент):
  1. запит за юзером
  2. рендер потрібної інформації
  3. Посилання на сторінку редагування.
  Логаут (AuthNavigation):
  1. Запит для логауту
  2. Редірект на сторінку логіну
  Header:
  1. Отримати стан аутентифікації з `useAuthStore` і на основі його рендерити за умовою ті чи інші посилання та компоненти.
2. Створити глобальний стор для аутентифікації (`useAuthStore`).
3. Підключити проксі-сервер, створивши екземпляр axios, базова адреса якоъ буде вести на зовнышный бекенд. Створити обробники маршрутів (route handlers) для кожного ендпойнту зовнішнього бекенду. Для цього потрібно просто скопіювати готову папку api, посилання на яке надається в ТЗ до ДЗ.
4. Написати функції/реєстрації/логауту/перевірки сессії/отримання юзеру/оновлення юзеру.
5. Переробити `lib/api.ts` в наступну структуру:
  - lib
    - api
      - api.ts
      - clientApi.ts
      - serverApi.ts
  - функції, які були в `api.ts` перенести в `clienApi.ts`, оскільки вони зможуть працювати тільки в клієнстських компонентах.
  - `lib/api/api.ts` - винести створення екземляру axios, який буде мати базову адресу проксі-серверу (localhost в дев розробці, посилання на живу сторінку після деплою на версель). Налаштовується через зміну оточення:
  ```ts
    {
      baseURL: `${process.env.NEXT_PUBLIC_API_URL}/api`
    }
  ```
  - lib/api/api.ts - також може зберігати всі сервісні інтерфейси і типи, які будуть використовуватись в `clientApi` та `serverApi`
  - В `serverApi` будуть міститись копії функцій, як і в `clientApi` з різницею в тому, що в серверних функціях потрібно отримувати кукі через `cookies()` і передавати в заголовки. Мають бути лише ті функції, яки будуть використовуватись в серверних компонентах і мідлварі.
  - зміна структури папок і файлів буде потребувати поправити імпорти усюди, де ці функції використовувались в компонентах. В серверних компонентах - серверні функції, в клієнтських компонентах - клієнтські функції.
6. Використати всі створені функції в компонентах сторнок відповідно до логіки сторінок.
7. Створити `AuthProvider` і підключити його `layout`. Задача `AuthProvider` - реалізувати тиху аутентифікацію (під час завантаження сторінки додатку буде виконуватись автоматично `checkSession`, який перевірить токени. На основі відповіді далі або виконувати запит за користувачем, або редіректити на сторінку логіну).
8. Додати `middleware`, який буде виконувати захист маршрутів на основі наявності токенів.
9. Сгрупувати всі маршрути в (private routes) та (auth routes).
10. Для (auth routes) маршрутів додати додатковий `layout`, який буде в `useEffect` виконувати `router.refresh()`. Потрібно для коректної роботи `middleware` в продакшені.